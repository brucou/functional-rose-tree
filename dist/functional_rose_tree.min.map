{"version":3,"sources":["index.js"],"names":["visitTree","breadthFirstTraverseTree","preorderTraverseTree","postOrderTraverseTree","reduceTree","forEachInTree","mapOverTree","pruneWhen","PATH_ROOT","POST_ORDER","PRE_ORDER","BFS","clone","a","undefined","JSON","parse","stringify","merge","objA","objB","Object","assign","times","fn","n","Array","apply","length","map","Number","call","updatePathInTraversalState","traversalState","subTree","subTreeChildren","forEach","subTreeChild","index","traversalStateParent","get","traversalStateChild","currentChildPath","path","set","isAdded","isVisited","concat","updateVisitInTraversalState","tree","traversalSpecs","store","lenses","traverse","emptyOrEmptyConstructor","empty","add","takeAndRemoveOne","isEmpty","getChildren","getLabel","setTree","visit","seedOrSeedConstructor","seed","Map","currentStore","visitAcc","clear","shift","subTrees","push","unshift","isLeaf","predicate","decoratedLenses","result","strategy","strategies","action","treeTraveerse","accumulator","mapFn","constructTree","getChildrenNumber","join","pathMap","mappedLabel","mappedChildren","mappedTree","pruneLenses","prunedTree","x"],"mappings":"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","file":"functional_rose_tree.min.map","sourcesContent":["const PATH_ROOT = [0];\r\nexport const POST_ORDER = \"POST_ORDER\";\r\nexport const PRE_ORDER = \"PRE_ORDER\";\r\nexport const BFS = \"BFS\";\r\n\r\n///// Utility functions\r\n// Cheap cloning, which is enough for our needs : we only clone seeds and empty values, which are generally simple\r\n// objects\r\nfunction clone(a){\r\n  return a === undefined ? undefined : JSON.parse(JSON.stringify(a))\r\n}\r\n\r\nfunction merge (objA, objB){\r\n  return Object.assign({}, objA, objB);\r\n}\r\n\r\nfunction times (fn, n){\r\n  return Array.apply(null, {length: n}).map(Number.call, Number).map(fn)\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param subTree\r\n * @param {Array} subTreeChildren\r\n * @modifies {traversalState}\r\n */\r\nfunction updatePathInTraversalState(traversalState, subTree, subTreeChildren) {\r\n  subTreeChildren.forEach((subTreeChild, index) => {\r\n    const traversalStateParent = traversalState.get(subTree);\r\n    // NOTE : if the path is already set we do not modify it. This allows for post-order traversal, which puts back\r\n    // the parent node into the children nodes to keep the original path for the parent node. So at any time, the\r\n    // `path` value can be trusted to be accurately describing the location of the node in the tree\r\n    const traversalStateChild = traversalState.get(subTreeChild);\r\n    const currentChildPath = traversalStateChild && traversalStateChild.path;\r\n\r\n    traversalState.set(\r\n      subTreeChild,\r\n      merge(traversalStateChild, {\r\n        isAdded: true,\r\n        isVisited: false,\r\n        path: currentChildPath || traversalStateParent.path.concat(index)\r\n      })\r\n    );\r\n  });\r\n}\r\n\r\n/**\r\n *\r\n * @param {Map} traversalState\r\n * @param tree\r\n * @modifies {traversalState}\r\n */\r\nfunction updateVisitInTraversalState(traversalState, tree) {\r\n  traversalState.set(\r\n    tree,\r\n    merge(traversalState.get(tree), { isVisited: true })\r\n  );\r\n}\r\n\r\n///// Core API\r\nexport function visitTree(traversalSpecs, tree) {\r\n  const { store, lenses, traverse } = traversalSpecs;\r\n  const { empty : emptyOrEmptyConstructor, add, takeAndRemoveOne, isEmpty } = store;\r\n  const { getChildren, getLabel, setTree } = lenses;\r\n  const { visit, seed  : seedOrSeedConstructor} = traverse;\r\n  const traversalState = new Map();\r\n  // NOTE : This allows to have seeds which are non-JSON objects, such as new Map(). We force a new here to make\r\n  // sure we have an object that cannot be modified out of the scope of visitTree and collaborators\r\n  const seed = (typeof seedOrSeedConstructor === 'function') ? new (seedOrSeedConstructor()) : clone(seedOrSeedConstructor) ;\r\n  const empty = (typeof emptyOrEmptyConstructor === 'function') ? new (emptyOrEmptyConstructor()) : clone(emptyOrEmptyConstructor) ;\r\n\r\n  // necessary to avoid destructive updates on input parameters\r\n  let currentStore = empty;\r\n  let visitAcc = seed;\r\n  add([tree], currentStore);\r\n  traversalState.set(tree, { isAdded: true, isVisited: false, path: PATH_ROOT });\r\n\r\n  while ( !isEmpty(currentStore) ) {\r\n    const subTree = takeAndRemoveOne(currentStore);\r\n    const subTreeChildren = getChildren(traversalState, subTree);\r\n\r\n    add(subTreeChildren, currentStore);\r\n    updatePathInTraversalState(traversalState, subTree, subTreeChildren);\r\n    visitAcc = visit(visitAcc, traversalState, subTree);\r\n    updateVisitInTraversalState(traversalState, subTree);\r\n  }\r\n\r\n  // Free the references to the tree/subtrees\r\n  traversalState.clear();\r\n\r\n  return visitAcc;\r\n}\r\n\r\nexport function breadthFirstTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.push.apply(store, subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function preorderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      // NOTE : vs. bfs, only `add` changes\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: { getChildren: (traversalState, subTree) => getChildren(subTree) },\r\n    traverse\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\nexport function postOrderTraverseTree(lenses, traverse, tree) {\r\n  const { getChildren } = lenses;\r\n  const isLeaf = (tree, traversalState) => getChildren(tree, traversalState).length === 0;\r\n  const { seed, visit } = traverse;\r\n  const predicate = (tree, traversalState) => traversalState.get(tree).isVisited || isLeaf(tree, traversalState)\r\n  const decoratedLenses = {\r\n    // For post-order, add the parent at the end of the children, that simulates the stack for the recursive function\r\n    // call in the recursive post-order traversal algorithm\r\n    // DOC : getChildren(tree, traversalState) also admit traversalState as argumnets but in second place\r\n    getChildren: (traversalState, tree) =>\r\n      predicate(tree, traversalState)\r\n        ? []\r\n        : getChildren(tree, traversalState).concat(tree)\r\n  };\r\n  const traversalSpecs = {\r\n    store: {\r\n      empty: [],\r\n      takeAndRemoveOne: store => store.shift(),\r\n      isEmpty: store => store.length === 0,\r\n      add: (subTrees, store) => store.unshift(...subTrees)\r\n    },\r\n    lenses: decoratedLenses,\r\n    traverse: {\r\n      seed: seed,\r\n      visit: (result, traversalState, tree) => {\r\n        // Cases :\r\n        // 1. label has been visited already : visit\r\n        // 2. label has not been visited, and there are no children : visit\r\n        // 3. label has not been visited, and there are children : don't visit, will do it later\r\n        if (predicate(tree, traversalState)) {\r\n          visit(result, traversalState, tree);\r\n        }\r\n\r\n        return result;\r\n      }\r\n    }\r\n  };\r\n\r\n  return visitTree(traversalSpecs, tree);\r\n}\r\n\r\n/**\r\n *\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, seed : *, visit : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function reduceTree(lenses, traverse, tree) {\r\n  const strategy = traverse.strategy;\r\n  const strategies = {\r\n    BFS: breadthFirstTraverseTree,\r\n    PRE_ORDER: preorderTraverseTree,\r\n    POST_ORDER: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  return strategies[strategy](lenses, traverse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree. Note that the traversal strategy does matter, as the function to\r\n * apply might perform effects.\r\n * @param {{getChildren : function}} lenses\r\n * @param {{strategy : *, action : function}} traverse\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function forEachInTree(lenses, traverse, tree) {\r\n  const { strategy, action } = traverse;\r\n\r\n  const strategies = {\r\n    [BFS]: breadthFirstTraverseTree,\r\n    [PRE_ORDER]: preorderTraverseTree,\r\n    [POST_ORDER]: postOrderTraverseTree\r\n  };\r\n\r\n  if (!(strategy in strategies)) throw `Unknown tree traversal strategy!`;\r\n\r\n  const treeTraveerse = {\r\n    seed: void 0,\r\n    visit: (accumulator, traversalState, tree) => action(tree, traversalState)\r\n  };\r\n  return strategies[strategy](lenses, treeTraveerse, tree);\r\n}\r\n\r\n/**\r\n * Applies a function to every node of a tree, while keeping the tree structure. Note that the traversal strategy in\r\n * that case does not matter, as all nodes will be traversed anyway, and the function to apply is assumed to be a\r\n * pure function.\r\n * @param {{getChildren : function, setChildren : function, setLabel : function}} lenses\r\n * @param {function} mapFn Function to apply to each node.\r\n * @param tree\r\n * @returns {*}\r\n */\r\nexport function mapOverTree(lenses, mapFn, tree) {\r\n  const { getChildren, constructTree, getLabel } = lenses;\r\n  const getChildrenNumber = (tree, traversalState) => getChildren(tree, traversalState).length;\r\n  const stringify = path => path.join(\".\");\r\n  const treeTraveerse = {\r\n    seed: () => Map,\r\n    visit: (pathMap, traversalState, tree) => {\r\n      const { path } = traversalState.get(tree);\r\n      // Paths are *stringified* because Map with non-primitive objects uses referential equality\r\n      const mappedLabel = mapFn(getLabel(tree));\r\n      const mappedChildren = times(\r\n        index => pathMap.get(stringify(path.concat(index))), getChildrenNumber(tree, traversalState));\r\n      const mappedTree = constructTree(mappedLabel, mappedChildren);\r\n      debugger\r\n      pathMap.set(stringify(path), mappedTree);\r\n\r\n      return pathMap;\r\n    }\r\n  };\r\n  const pathMap = postOrderTraverseTree(lenses, treeTraveerse, tree);\r\n  const mappedTree = pathMap.get(stringify(PATH_ROOT));\r\n  pathMap.clear();\r\n\r\n  return mappedTree;\r\n}\r\n\r\n\r\n/**\r\n * Returns a tree where all children of nodes which fails a predicate are pruned. Note that the node failing the\r\n * predicate will remain in the tree : only the children will be pruned. If it is wanted to prune also the failing\r\n * node in addition to its children, the `getChildren` function can make use of the second parameter\r\n * `traversalState` to do so\r\n * @param lenses\r\n * @param {function} predicate\r\n * @param tree\r\n * @returns tree\r\n */\r\nexport function pruneWhen(lenses, predicate, tree) {\r\n  // As we need to return a tree, it will be convenient to use mapOverTree\r\n  const { getChildren } = lenses;\r\n  const pruneLenses = merge(lenses, {\r\n    getChildren: (tree, traversalState) => {\r\n      if (predicate(tree, traversalState)) {\r\n        // prune that branch\r\n        return []\r\n      }\r\n      else {\r\n        return getChildren(tree, traversalState)\r\n      }\r\n    }\r\n  });\r\n  const prunedTree = mapOverTree(pruneLenses, x => x, tree);\r\n\r\n  return prunedTree\r\n}\r\n\r\n"]}